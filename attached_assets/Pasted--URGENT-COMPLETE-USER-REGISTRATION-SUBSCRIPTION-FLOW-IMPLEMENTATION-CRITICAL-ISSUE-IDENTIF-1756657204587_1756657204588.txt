

# URGENT: COMPLETE USER REGISTRATION & SUBSCRIPTION FLOW IMPLEMENTATION

## CRITICAL ISSUE IDENTIFIED
I've tested the current registration process and found a complete gap in the user journey. The following essential flow is missing and must be implemented immediately:

## REQUIRED IMPLEMENTATION - COMPLETE USER JOURNEY

### 1. EMAIL VERIFICATION SYSTEM
**Current Status:** Missing
**Required Implementation:**
- When user registers, generate verification code and send to their email
- Store verification code in production database with expiration timestamp
- Create UI window for code entry after registration
- Verify code against production database before proceeding

```typescript
// Example production implementation (not stub)
export async function registerUser(email: string, password: string, tier: string) {
  // Create user in production database
  const user = await db.insert(users).values({ email, password, tier, verified: false }).returning();
  
  // Generate real verification code
  const verificationCode = generateSecureCode();
  await db.insert(verificationCodes).values({
    userId: user[0].id,
    code: verificationCode,
    expiresAt: addHours(new Date(), 24) // Real expiration
  });
  
  // Send actual email to user
  await sendRealEmail(email, 'Verify your account', `Your code is: ${verificationCode}`);
  
  return user;
}
```

### 2. VERIFICATION CODE ENTRY UI
**Current Status:** Missing
**Required Implementation:**
- Create modal/page for code entry after registration
- Connect to production database for code validation
- Handle expired/invalid codes with proper error messages
- Proceed to payment only after successful verification

```typescript
// Production verification endpoint
export async function verifyCode(userId: string, code: string) {
  // Check against real database records
  const verificationRecord = await db.select().from(verificationCodes)
    .where(and(
      eq(verificationCodes.userId, userId),
      eq(verificationCodes.code, code),
      gt(verificationCodes.expiresAt, new Date())
    ));
    
  if (!verificationRecord.length) {
    throw new Error('Invalid or expired verification code');
  }
  
  // Update real user record
  await db.update(users).set({ verified: true }).where(eq(users.id, userId));
  
  return { success: true };
}
```

### 3. TIER-BASED PAYMENT DISPLAY
**Current Status:** Missing
**Required Implementation:**
- Display correct payment amount for selected tier from production data
- Connect to real Stripe pricing plans (not hardcoded values)
- Show tier features and benefits from production database
- Handle currency conversion if applicable

```typescript
// Get real pricing from production database
export async function getTierPricing(tier: string) {
  const pricing = await db.select().from(subscriptionTiers)
    .where(eq(subscriptionTiers.name, tier));
    
  if (!pricing.length) {
    throw new Error('Invalid subscription tier');
  }
  
  return {
    amount: pricing[0].price, // Real price from database
    currency: pricing[0].currency,
    interval: pricing[0].interval
  };
}
```

### 4. PAYMENT PROCESSING & REDIRECTION
**Current Status:** Missing
**Required Implementation:**
- Process real Stripe payment for selected tier
- Update user subscription status in production database upon success
- Redirect to appropriate dashboard based on user's tier after payment
- Handle payment failures with proper error messages

```typescript
// Production payment processing
export async function processPayment(userId: string, tier: string, paymentMethodId: string) {
  // Get real user data
  const user = await db.select().from(users).where(eq(users.id, userId));
  
  // Get real tier pricing
  const pricing = await getTierPricing(tier);
  
  // Create real Stripe subscription
  const subscription = await stripe.subscriptions.create({
    customer: user[0].stripeCustomerId,
    items: [{ price: pricing.stripePriceId }],
    payment_behavior: 'default_incomplete',
    expand: ['latest_invoice.payment_intent'],
  });
  
  // Update production database
  await db.update(users).set({
    subscriptionTier: tier,
    subscriptionStatus: 'active',
    stripeSubscriptionId: subscription.id
  }).where(eq(users.id, userId));
  
  // Determine correct dashboard based on tier
  const dashboardUrl = getDashboardUrlForTier(tier);
  
  return { success: true, redirectUrl: dashboardUrl };
}
```

## PRODUCTION DATA REQUIREMENTS
- All verification codes must be stored in production database
- All pricing must come from production subscription tiers table
- All payments must process through real Stripe API
- All user status updates must reflect in production database
- Dashboard redirection must be based on real user tier in production database

## TESTING REQUIREMENTS
Provide end-to-end testing instructions using:
1. Real email addresses for verification
2. Production database for code validation
3. Real Stripe test credentials for payment
4. Production user records for status verification

## DELIVERABLES
1. Complete implementation of all missing flow components
2. Code evidence showing production data integration (no stubs)
3. Testing instructions for the entire user journey
4. Verification that flow works with real production data

## PRIORITY LEVEL: CRITICAL
This implementation is required immediately. The current registration flow is incomplete and non-functional for real users.

**REMINDER:** Every feature must use exclusively live production data. Any component using mock, demo, or hardcoded data will be rejected. Verify all implementations against actual production databases and Stripe services before delivery.