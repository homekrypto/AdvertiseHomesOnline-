

# COMPLETE USER REGISTRATION & SUBSCRIPTION FLOW DESCRIPTION

## OVERVIEW
The complete user registration and subscription flow consists of 4 critical stages that must be implemented using exclusively production data. This flow transforms a new visitor into a fully subscribed user with access to the appropriate dashboard.

## STAGE 1: USER REGISTRATION

### Frontend Implementation
- **Registration Form Components:**
  ```jsx
  // Real form with production validation
  <form onSubmit={handleRegistration}>
    <input type="email" placeholder="Email" required />
    <input type="password" placeholder="Password" required />
    <select value={selectedTier} onChange={(e) => setSelectedTier(e.target.value)}>
      <option value="free">Free</option>
      <option value="premium">Premium - $29/month</option>
      <option value="agent">Agent - $49/month</option>
      <option value="agency">Agency - $99/month</option>
    </select>
    <button type="submit">Register</button>
  </form>
  ```

### Backend Implementation
- **Registration Endpoint (Production Data Only):**
  ```typescript
  // server/routes.ts
  app.post('/api/register', async (req, res) => {
    const { email, password, tier } = req.body;
    
    // Check if user exists in production database
    const existingUser = await db.select().from(users).where(eq(users.email, email));
    if (existingUser.length) throw new Error('User already exists');
    
    // Hash password with production-grade security
    const hashedPassword = await bcrypt.hash(password, 12);
    
    // Create user in production database
    const newUser = await db.insert(users).values({
      email,
      password: hashedPassword,
      tier,
      verified: false,
      status: 'inactive'
    }).returning();
    
    // Generate real verification code
    const verificationCode = generateSecureCode();
    await db.insert(verificationCodes).values({
      userId: newUser[0].id,
      code: verificationCode,
      expiresAt: addHours(new Date(), 24)
    });
    
    // Send actual email to user
    await sendRealEmail(email, 'Verify Your Account', `Your verification code is: ${verificationCode}`);
    
    res.json({ success: true, userId: newUser[0].id });
  });
  ```

## STAGE 2: EMAIL VERIFICATION

### Frontend Implementation
- **Verification Code Entry UI:**
  ```jsx
  // Appears after successful registration
  <div className="verification-modal">
    <h2>Verify Your Email</h2>
    <p>We've sent a code to {email}</p>
    <input 
      type="text" 
      placeholder="Enter verification code" 
      value={verificationCode}
      onChange={(e) => setVerificationCode(e.target.value)}
    />
    <button onClick={handleVerification}>Verify</button>
    <button onClick={handleResendCode}>Resend Code</button>
  </div>
  ```

### Backend Implementation
- **Verification Endpoint (Production Database):**
  ```typescript
  // server/routes.ts
  app.post('/api/verify-email', async (req, res) => {
    const { userId, code } = req.body;
    
    // Check against real verification codes in production database
    const verificationRecord = await db.select().from(verificationCodes)
      .where(and(
        eq(verificationCodes.userId, userId),
        eq(verificationCodes.code, code),
        gt(verificationCodes.expiresAt, new Date())
      ));
    
    if (!verificationRecord.length) {
      throw new Error('Invalid or expired verification code');
    }
    
    // Update real user record in production database
    await db.update(users).set({ verified: true }).where(eq(users.id, userId));
    
    // Clean up verification code
    await db.delete(verificationCodes).where(eq(verificationCodes.userId, userId));
    
    res.json({ success: true });
  });
  ```

## STAGE 3: PAYMENT PROCESSING

### Frontend Implementation
- **Payment Display with Real Pricing:**
  ```jsx
  // Fetched from production database
  const { data: tierPricing } = useQuery(['/api/pricing', selectedTier], async () => {
    const response = await fetch(`/api/pricing?tier=${selectedTier}`);
    return response.json();
  });

  // Payment form with real Stripe integration
  <Elements stripe={stripePromise}>
    <PaymentForm 
      amount={tierPricing.amount}
      currency={tierPricing.currency}
      onSuccess={handlePaymentSuccess}
    />
  </Elements>
  ```

### Backend Implementation
- **Pricing Endpoint (Production Data):**
  ```typescript
  // server/routes.ts
  app.get('/api/pricing', async (req, res) => {
    const { tier } = req.query;
    
    // Fetch real pricing from production database
    const pricing = await db.select().from(subscriptionTiers)
      .where(eq(subscriptionTiers.name, tier));
    
    if (!pricing.length) throw new Error('Invalid subscription tier');
    
    res.json({
      amount: pricing[0].price,
      currency: pricing[0].currency,
      stripePriceId: pricing[0].stripePriceId
    });
  });
  ```

- **Payment Processing Endpoint (Real Stripe):**
  ```typescript
  // server/routes.ts
  app.post('/api/process-payment', async (req, res) => {
    const { userId, paymentMethodId, tier } = req.body;
    
    // Get real user data from production database
    const user = await db.select().from(users).where(eq(users.id, userId));
    
    // Get real tier pricing
    const pricing = await db.select().from(subscriptionTiers)
      .where(eq(subscriptionTiers.name, tier));
    
    // Create real Stripe subscription
    const subscription = await stripe.subscriptions.create({
      customer: user[0].stripeCustomerId,
      items: [{ price: pricing[0].stripePriceId }],
      payment_behavior: 'default_incomplete',
      expand: ['latest_invoice.payment_intent'],
    });
    
    // Update production database
    await db.update(users).set({
      subscriptionStatus: 'active',
      stripeSubscriptionId: subscription.id,
      currentPeriodEnd: new Date(subscription.current_period_end * 1000)
    }).where(eq(users.id, userId));
    
    // Record payment in production database
    await db.insert(payments).values({
      userId,
      amount: pricing[0].price,
      stripePaymentIntentId: subscription.latest_invoice.payment_intent.id,
      status: 'succeeded'
    });
    
    res.json({ success: true, subscriptionId: subscription.id });
  });
  ```

## STAGE 4: DASHBOARD REDIRECTION

### Frontend Implementation
- **Redirection Logic Based on Real Tier:**
  ```typescript
  // After successful payment
  const handlePaymentSuccess = async () => {
    // Fetch updated user data from production database
    const { data: userData } = await supabase
      .from('users')
      .select('*')
      .eq('id', userId)
      .single();
    
    // Redirect to appropriate dashboard based on real tier
    switch (userData.tier) {
      case 'free':
        window.location.href = '/dashboard/free';
        break;
      case 'premium':
        window.location.href = '/dashboard/premium';
        break;
      case 'agent':
        window.location.href = '/dashboard/agent';
        break;
      case 'agency':
        window.location.href = '/dashboard/agency';
        break;
      default:
        window.location.href = '/dashboard';
    }
  };
  ```

## COMPLETE FLOW VISUALIZATION

```
1. REGISTRATION
   User → Registration Form → Backend → Production Database
   ↓
   Generate Verification Code → Send Real Email
   ↓
2. VERIFICATION
   User → Enter Code → Backend → Verify Against Production Database
   ↓
   Update User Status → Clean Up Verification Code
   ↓
3. PAYMENT
   User → Payment Form → Backend → Fetch Real Pricing
   ↓
   Process Real Stripe Payment → Update Production Database
   ↓
4. REDIRECTION
   User → Dashboard Based on Real Tier in Production Database
```

## PRODUCTION DATA REQUIREMENTS

1. **User Data:** All user information stored in production `users` table
2. **Verification Codes:** All codes stored in production `verification_codes` table
3. **Pricing Data:** All tier pricing fetched from production `subscription_tiers` table
4. **Payment Records:** All transactions stored in production `payments` table
5. **Stripe Integration:** Real Stripe API calls with production credentials

## TESTING INSTRUCTIONS

1. **Registration Test:**
   - Use real email address
   - Select a subscription tier
   - Verify user record in production database
   - Check email for verification code

2. **Verification Test:**
   - Enter verification code
   - Verify user status update in production database
   - Confirm code deletion from production database

3. **Payment Test:**
   - Verify pricing matches production database
   - Use real Stripe test card (4242 4242 4242 4242)
   - Confirm payment record in production database
   - Verify Stripe dashboard for real transaction

4. **Redirection Test:**
   - Confirm user is redirected to correct dashboard
   - Verify user tier in production database matches dashboard

This complete flow must be implemented using exclusively production data with no mock or hardcoded values at any stage.