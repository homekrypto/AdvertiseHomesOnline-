

# PROMPT: COMPREHENSIVE DEBUGGING OF EMAIL VERIFICATION AND AUTHENTICATION ISSUES

## OBJECTIVE
Diagnose and resolve critical authentication failures in the email verification flow. The system successfully sends verification emails but fails during verification and subsequent authentication, with undefined user data and 401/400 errors.

## CRITICAL ISSUES IDENTIFIED

### Issue 1: Email Verification Request (400 Bad Request)
- **Frontend Error:** `EmailVerification.tsx:31` shows `{userId: undefined, email: undefined, code: '124711'}`
- **API Error:** `POST /api/auth/verify-email 400 (Bad Request)`
- **Problem:** Verification request missing required `userId` and `email` parameters

### Issue 2: Authentication Status (401 Unauthorized)
- **Frontend Error:** `GET /api/auth/user 401 (Unauthorized)`
- **Problem:** User not authenticated after verification attempt
- **Impact:** User cannot access protected routes or dashboard

## SYSTEMATIC DEBUGGING APPROACH

### Phase 1: Email Verification Flow Analysis
**Investigate how verification parameters are handled:**
- Examine `EmailVerification.tsx` component to understand:
  - How `userId` and `email` should be retrieved
  - Current state management implementation
  - Parameter passing mechanism to verification endpoint
- Check verification link structure in emails:
  - Are `userId` and `email` properly included in verification URL?
  - How are these parameters being extracted on the verification page?
- Analyze verification form submission:
  - How is the verification code combined with user data?
  - What triggers the verification request?

**Deliverables:**
- Code analysis of `EmailVerification.tsx`
- Verification link structure examination
- Parameter flow diagram from email to API request

### Phase 2: Backend Verification Endpoint Analysis
**Investigate `/api/auth/verify-email` endpoint:**
- Examine endpoint implementation:
  - Required parameters and validation logic
  - Error handling for missing parameters
  - Verification code checking mechanism
- Check database operations:
  - How verification codes are stored and retrieved
  - User record update process after verification
- Analyze session creation:
  - How authentication session is established after verification
  - Session storage mechanism (cookies, tokens, etc.)

**Deliverables:**
- Endpoint code analysis
- Database query examination
- Session creation flow documentation

### Phase 3: Authentication State Management
**Investigate authentication persistence:**
- Examine `/api/auth/user` endpoint:
  - Authentication middleware implementation
  - Session validation mechanism
  - Error handling for unauthorized access
- Check frontend authentication state:
  - How authentication status is tracked
  - Token/cookie handling in API requests
  - State management after verification

**Deliverables:**
- Authentication middleware analysis
- Frontend state management examination
- API request credential handling review

### Phase 4: End-to-End Flow Testing
**Test complete verification and authentication flow:**
1. **Registration Flow:**
   - Create new user and capture verification link
   - Examine verification link structure
   - Verify user record in database

2. **Verification Flow:**
   - Access verification page with valid link
   - Check parameter extraction in frontend
   - Submit verification with valid code
   - Monitor API request and response

3. **Authentication Flow:**
   - Check session establishment after verification
   - Test `/api/auth/user` endpoint
   - Verify authentication state in frontend

**Deliverables:**
- Complete test logs
- Network request analysis
- Database state verification
- Authentication status confirmation

## TECHNICAL INVESTIGATION POINTS

### Frontend Investigation
```jsx
// EmailVerification.tsx - Parameter extraction
// How are userId and email retrieved?
const { userId, email } = useParams(); // From URL?
const location = useLocation(); // From state?
const storedData = localStorage.getItem('verificationData'); // From storage?

// Form submission - How is data sent?
const handleVerify = async () => {
  const response = await fetch('/api/auth/verify-email', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ userId, email, code }) // Are these defined?
  });
};
```

### Backend Investigation
```typescript
// /api/auth/verify-email endpoint
app.post('/api/auth/verify-email', async (req, res) => {
  const { userId, email, code } = req.body; // Are these being received?
  
  // Validation logic
  if (!userId || !email || !code) {
    return res.status(400).json({ error: 'Missing required fields' });
  }
  
  // Verification code check
  const verification = await db.select().from(verificationCodes)
    .where(and(
      eq(verificationCodes.userId, userId),
      eq(verificationCodes.code, code),
      gt(verificationCodes.expiresAt, new Date())
    ));
    
  // Session creation after verification
  if (verification.length) {
    // How is session established?
    req.session.userId = userId; // Session-based?
    // Or JWT token?
    const token = jwt.sign({ userId }, process.env.JWT_SECRET);
  }
});
```

### Authentication Investigation
```typescript
// /api/auth/user endpoint
app.get('/api/auth/user', requireAuth, async (req, res) => {
  // requireAuth middleware - how does it validate?
  const user = await db.select().from(users)
    .where(eq(users.id, req.session.userId)); // Or from JWT?
    
  res.json(user);
});
```

## TESTING REQUIREMENTS

### 1. Verification Link Testing
- Register new user and capture verification email
- Examine verification link structure
- Test direct access to verification link
- Verify parameter extraction works correctly

### 2. Verification API Testing
- Test with complete parameters: `{ userId, email, code }`
- Test with missing parameters to trigger 400 errors
- Verify database updates after successful verification
- Check session establishment in response

### 3. Authentication Testing
- Test `/api/auth/user` immediately after verification
- Check session persistence across page reloads
- Verify authentication state in frontend
- Test protected route access

## DELIVERABLES

### 1. Root Cause Analysis
- Exact cause of undefined parameters in verification request
- Reason for 401 error after verification
- Breakdown point in authentication flow

### 2. Code Fixes
- Updated `EmailVerification.tsx` with proper parameter handling
- Fixed verification endpoint with robust error handling
- Corrected authentication middleware and session management

### 3. Testing Evidence
- Complete end-to-end test logs
- Network request/response analysis
- Database state verification
- Authentication status confirmation

### 4. Production Verification
- Confirmation that fixes work with production data
- Verification that no mock data is used
- Evidence of complete user flow functionality

## IMPLEMENTATION PRIORITY
1. **Critical (Immediate):** Email verification parameter handling
2. **High (2-4 hours):** Backend verification endpoint fixes
3. **Medium (4-6 hours):** Authentication state management
4. **Low (6-8 hours):** Comprehensive testing and documentation

## SUCCESS CRITERIA
- Verification requests include valid `userId` and `email`
- Verification endpoint processes requests without 400 errors
- Users are properly authenticated after verification
- `/api/auth/user` returns user data with 200 status
- Complete registration/verification/authentication flow works end-to-end

## PRODUCTION REQUIREMENTS
**Every feature must use exclusively live production data. Any component using mock, demo, or hardcoded data will be rejected. Verify all implementations against actual production databases and services before delivery.**

Please confirm receipt and provide a detailed debugging plan that systematically addresses each phase of investigation, with specific focus on the parameter passing issue and authentication establishment after verification.